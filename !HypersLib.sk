#Version HYPER-COMMISSION-USE-V1.5.6

#Requirements
#Modern Skript, 2.9+ (mostly tested on 2.10)
#Skript-Reflect
#SkBee
#SkQuery
#PaperMC or derivatives for NMS based things

#Change this to your plugin/script's name
#If you change this after storing data with tags, they will no longer work
options:
	pluginname: hyperslib

#Reminds the user to enable memory variables once they restart the server with the library for the first time and then later.
 
on skript start:
	if {-Memory_variable} is set:
		send "&ePlease enable memory variables for much better performance and near 0 lag, they are easy to enable." to console
		send "&ePlease read https://sovdee.gitbook.io/skript-tutorials/core-concepts/variables/memory-variables-metadata-and-alternatives" to console
		send "&eIf you still don't know how to, DM hyperdondonreal on Discord and ask for help." to console
	set {-Memory_variable} to true

#Import Java classes to be able to use
import:
	java.time.Duration
	java.lang.System
	org.bukkit.Bukkit
	java.lang.Character
	org.bukkit.event.player.PlayerInteractEntityEvent
	org.bukkit.event.player.PlayerInteractEvent
	org.bukkit.inventory.EquipmentSlot
	org.bukkit.persistence.PersistentDataHolder
	org.bukkit.persistence.PersistentDataContainer
	org.bukkit.persistence.PersistentDataType
	org.bukkit.event.block.Action

	#NMS. We are using Mojang mappings, so, PaperMC is required.
	#Entities
	net.minecraft.world.entity.EntityType
	net.minecraft.world.entity.monster.EnderMan
	net.minecraft.world.entity.monster.Creeper
	net.minecraft.world.entity.monster.CaveSpider
	net.minecraft.world.entity.monster.Spider
	#Packets
	net.minecraft.network.protocol.game.ClientboundAddEntityPacket
	net.minecraft.network.protocol.game.ClientboundSetCameraPacket
	net.minecraft.network.protocol.game.ClientboundRespawnPacket
	net.minecraft.network.protocol.game.ClientboundSetPassengersPacket
	net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket
	net.minecraft.network.protocol.game.ClientboundCooldownPacket
	#Other Objects
	net.minecraft.core.BlockPos
	net.minecraft.world.phys.AABB
	#Not NMS, used for NMS parts
	org.bukkit.entity.Mob

on load:
	set {-{@pluginname}::APIChange} to isAtAPIChange()

#Checks if version is 1.20.4 or lower. At 1.20.5, Mojang has changed the NBT formatDouble and so has the server APIs. The change to the Bukkit API have been drastic.
local function isAtAPIChange() :: boolean:
	if any:
		Bukkit.getBukkitVersion() contains "1.12"
		Bukkit.getBukkitVersion() contains "1.13"
		Bukkit.getBukkitVersion() contains "1.14"
		Bukkit.getBukkitVersion() contains "1.15"
		Bukkit.getBukkitVersion() contains "1.16"
		Bukkit.getBukkitVersion() contains "1.17"
		Bukkit.getBukkitVersion() contains "1.18"
		Bukkit.getBukkitVersion() contains "1.19"
		Bukkit.getBukkitVersion() contains "1.20.1"
		Bukkit.getBukkitVersion() contains "1.20.2"
		Bukkit.getBukkitVersion() contains "1.20.3"
		Bukkit.getBukkitVersion() contains "1.20.4"
	then:
		return false
	return true

condition server[(-| )version] is at [bukkit(-| )](API|api) change:
	check:
		{-{@pluginname}::APIChange} is true
		continue

condition server[(-| )version] (is not|isn't) at [bukkit(-| )](API|api) change:
	check:
		{-{@pluginname}::APIChange} is false
		continue

#Returns a random location out of a location within a radius.
function getRTP(loc: location, radius: int) :: location:
	set {_x} to x coord of {_loc} + (random integer between ({_radius}-{_radius}-{_radius}) and {_radius})
	set {_z} to z coord of {_loc} + (random integer between ({_radius}-{_radius}-{_radius}) and {_radius})
	return location of highest block at location at ({_x}, 0, {_z}) in world of {_loc}

#Changes number without a decimal number to have one.
function formatDouble(num: number) :: string:
	if mod({_num}, 1) is 0:
		return "%{_num}%.0"
	else:
		return "%{_num}%"

expression cooldown %string% [for %player%]:
	get:
		if expr-2 is set:
			set {_id} to "%uuid of expr-2%:%expr-1%"
		else:
			set {_id} to expr-1
		return getActionBarCooldown({_id})
	set:
		if expr-2 is set:
			set {_id} to "%uuid of expr-2%:%expr-1%"
		else:
			set {_id} to expr-1
		setCooldown({_id}, ticks of (change value * 50))

condition cooldown %string% [for %player%] (positive:is ready|negative:is(n't| not) ready):
	check:
		if expr-2 is set:
			set {_id} to "%uuid of expr-2%:%expr-1%"
		else:
			set {_id} to expr-1
		if first element of parser tags is "positive":
			isCooldownReady({_id}) is true
			continue
		else:
			if isCooldownReady({_id}) is not true:
				continue


#This is old, this is for compatibility purposes.

#Gets the cooldown variable
function getCooldown(cooldown: text) :: int:
	return {-{@pluginname}::Cooldown::%{_cooldown}%}

#Gets the cooldown's seconds, does not return the whole cooldown in seconds.
function getCooldownSeconds(cooldown: text) :: int:
	add Duration.ofMillis({-{@pluginname}::Cooldown::%{_cooldown}%} - System.currentTimeMillis()).toSecondsPart() to {_coo}
	if {_coo} is 60:
		set {_coo} to 0
	return {_coo}

#Gets the cooldown's minutes.
function getCooldownMinutes(cooldown: text) :: int:
	set {_coo} to Duration.ofMillis({-{@pluginname}::Cooldown::%{_cooldown}%} - System.currentTimeMillis()).toMinutes()
	if Duration.ofMillis({-{@pluginname}::Cooldown::%{_cooldown}%} - System.currentTimeMillis()).toSecondsPart() is 60:
		add 1 to {_coo}
	return {_coo}
	
#Sets the cooldown. 2nd argument (cooldown to be set) must be in milliseconds. Use toMilliseconds().
function setCooldown(cooldown: text, value: number):
	set {-{@pluginname}::Cooldown::%{_cooldown}%} to System.currentTimeMillis() + {_value}

#Checks if a cooldown exists, what else?
function doesCooldownExist(cooldown: text) :: boolean:
	if {-{@pluginname}::Cooldown::%{_cooldown}%} is set:
		return true
	else:
		return false

#Checks if a cooldown is ready to use
function isCooldownReady(cooldown: text) :: boolean:
	if doesCooldownExist({_cooldown}) is false:
		return true
	if getCooldown({_cooldown}) - System.currentTimeMillis() <= 1000:
		return true
	else:
		return false

#Returns your value as in millseconds, used for cooldowns.
function toMilliseconds(minutes: int, seconds: int) :: int:
	set {_final} to 0
	loop {_minutes} times:
		add 60000 to {_final}
	loop {_seconds} times:
		add 1000 to {_final}

	return {_final}
	
#Returns cooldown in how it would look like in an action bar.
function getActionBarCooldown(cooldow: text, show_decimal: boolean = false) :: text:
	if isCooldownReady({_cooldow}) is true:
		set {_cooldown} to "&aReady!"
	else:
		if {_show_decimal} is false:
			set {_cooldown_seconds} to getCooldownSeconds({_cooldow})

			set {_cooldown_minutes} to getCooldownMinutes({_cooldow})
		else:
			set {_cooldown_seconds} to formatDouble(getCooldownSeconds({_cooldow}))

			set {_cooldown_minutes} to formatDouble(getCooldownMinutes({_cooldow}))

		
		if {_cooldown_minutes} > 0:
			if {_cooldown_seconds} < 1:
				set {_cooldown} to "&b%{_cooldown_minutes}%m"
			else:
				set {_cooldown} to "&b%{_cooldown_minutes}%m %{_cooldown_seconds}%s"
		if {_cooldown_minutes} < 1:
			if {_cooldown_seconds} > 0:
				set {_cooldown} to "&b%{_cooldown_seconds}%s"

		if {_cooldown} is not set:
			set {_cooldown} to "&aReady!"

		if {_show_decimal} is true:
			replace all "m" and "s" with "" in {_cooldown}
			
	
	return {_cooldown}

#Makes the item unremovable from your inventory
function addUnremovableItem(i: item, checkName: boolean = true, checkLore: boolean = true):
	if {-{@pluginname}::UnremovableItems::*} is set:
		set {_size} to size of {-{@pluginname}::UnremovableItems::*} + 1
	else:
		set {_size} to 1
	set {-{@pluginname}::UnremovableItems::%{_size}%} to {_i}
	set {-{@pluginname}::UnremovableItems::checkNames::%{_size}%} to {_checkName}
	set {-{@pluginname}::UnremovableItems::checkLore::%{_size}%} to {_checkLore}

expression unremovable %itemtype%:
	return type: item
	get:
		return expr-1 with boolean tag data "unremovable" set to true

#Checks if an item is removable (duh)
function isUnremovable(i: item) :: boolean:
	if {_i} has boolean tag data "unremovable":
		return true
	loop {-{@pluginname}::UnremovableItems::*}:
		if loop-value is {_i}:
			return true
		if {-{@pluginname}::UnremovableItems::checkNames::%loop-iteration%} is true:
			if name of loop-value is name of {_i}:
				return true
		if {-{@pluginname}::UnremovableItems::checkLore::%loop-iteration%} is true:
			if lore of loop-value is lore of {_i}:
				return true
	return false

on inventory click:
	if player's inventory is event-inventory:
		if any:
			click action is shift+lmb
			click action is shift+rmb
		then:
			if isUnremovable(event-item) is true:
				cancel event

on inventory click:
	if player's open inventory is event-inventory:
		if any:
			click action is lmb
			click action is rmb
		then:
			if isUnremovable(player's cursor slot) is true:
				cancel event

on inventory click:
	if player's open inventory is event-inventory:
		if click action is number key:
			if isUnremovable(player.getInventory().getItem(event.getHotbarButton())) is true:
				cancel event
		if click action is swap offhand:
			if isUnremovable(player's off hand item) is true:
				cancel event


on inventory drag:
	set {_slots::*} to event.getRawSlots()
	loop {_slots::*}:
		set {_slot} to "%loop-value%"
		replace all "[" with "" in {_slot}
		replace all "]" with "" in {_slot}
		set {_list::*} to split {_slot} at ", "

	loop {_list::*}:
		set {_num} to loop-value parsed as integer
		if player's open inventory is event.getView().getInventory({_num}):
			if isUnremovable(past event-item) is true:
				cancel event

on death:
	loop the drops:
		isUnremovable(loop-value) is true
		remove loop-value from the drops

on drop:
	isUnremovable(event-item) is true
	cancel event

on inventory click:
	isUnremovable(event-item) is true
	event-inventory is player's inventory
	player cannot hold 1 water bucket #water buckets dont stack, good for this case
	cancel event

on PlayerInteractEntityEvent:
	if event.getHand() is EquipmentSlot.HAND:
		isUnremovable(event.getPlayer()'s held item) is true
		event.setCancelled(true)

	if event.getHand() is EquipmentSlot.OFF_HAND:
		isUnremovable(event.getPlayer()'s off hand item) is true
		event.setCancelled(true)

on PlayerInteractEvent:
	if event.getAction() is not Action.RIGHT_CLICK_BLOCK:
		stop
	if event.getHand() is EquipmentSlot.HAND:
		isUnremovable(event.getPlayer()'s held item) is true
		event.setCancelled(true)

	if event.getHand() is EquipmentSlot.OFF_HAND:
		isUnremovable(event.getPlayer()'s off hand item) is true
		event.setCancelled(true)

local function toSmallCaps(string: text) :: text:
	set {_normalText::*} to "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y" and "Z" #!RAT was here, Added a Y, you dumbass hyper.
	set {_smallText::*} to "ᴀ", "ʙ", "ᴄ", "ᴅ", "ᴇ", "ғ", "ɢ", "ʜ", "ɪ", "ᴊ", "ᴋ", "ʟ", "ᴍ", "ɴ", "ᴏ", "ᴘ", "ǫ", "ʀ", "s", "ᴛ", "ᴜ", "ᴠ", "ᴡ", "x", "ʏ" and "ᴢ"
	set {_finalString} to ""
	set {_skipAmount} to 0

	set {_string} to raw {_string}
	loop {_string}'s length times:
		set {_index} to loop-iteration - 1
		set {_char} to char at {_index} in {_string}
		if {_skipAmount} > 0:
			add {_char} to {_finalString}
			remove 1 from {_skipAmount}
			continue
		loop {_normalText::*}:
			if {_char} is "<":
				set {_bracketIndex} to {_index}
				while char at {_bracketIndex} in {_string} is not ">":
					if {_bracketIndex} > {_string}'s length - 1:
						exit 3 sections
					add 1 to {_bracketIndex}
					add 1 to {_skipAmount}
			if {_char} is "&":
				if {_string}'s length <= {_index} + 1:
					exit 2 sections
				char at {_index} + 1 in {_string} is not "&"
				char at {_index} + 1 in {_string} is not " "
				add 1 to {_skipAmount}

			if Character.isLetter({_char}.toUpperCase()) is not true:
				add {_char} to {_finalString}
				exit 2 sections
			if loop-value-2 is {_char}:
				add {_smallText::%loop-iteration-2%} to {_finalString}
	return colored {_finalString}
	
expression:
	patterns:
		small caps from %strings%
		%strings% (as|to|in) small caps
	get:
		set {_strings::*} to expr-1
		loop {_strings::*}:
			add toSmallCaps(loop-value) to {_list::*}
		return {_list::*}

#All geyser/bedrock players have a uuid that start with 00000000-0000-0000-000
#No Java player would be able to get this uuid, it's not a valid UUID that could be generated from Mojang.
condition %player% is [a] (bedrock|geyser|floodgate) player:
	check:
		expr-1's uuid starts with "00000000"
		continue
condition %player% (is not|isn't) [a] (bedrock|geyser|floodgate) player:
	check:
		expr-1's uuid doesn't start with "00000000"
		continue

#We are using NMS here. Code from PoaSK.
#Only supports enderman, creeper, spider, cave spider, and player (default for players, duh)
effect:
	patterns:
		change vision of %players% to [entity] %entitytype%
		change %players%'s vision to [entity] %entitytype%
	parse:
		#Create errors for unsupported entities
		if any:
			"%expr-2%" is "enderman"
			"%expr-2%" is "creeper"
			"%expr-2%" is "spider"
			"%expr-2%" is "cave spider"
			"%expr-2%" is "player"
		then:
			continue
	trigger:
		set {_players::*} to expr-1
		loop {_players::*}:
			setVision(loop-value, expr-2)

local function setVision(player: player, entity: object):
	set {_serverPlayer} to {_player}.getHandle()
	set {_serverLevel} to {_player}.getWorld().getHandle()
	
	if "%{_entity}%" is "enderman":
		set {_NMSEntity} to new EnderMan(EntityType.ENDERMAN, {_serverLevel})
	else if "%{_entity}%" is "creeper":
		set {_NMSEntity} to new Creeper(EntityType.CREEPER, {_serverLevel})
	else if "%{_entity}%" is "spider":
		set {_NMSEntity} to new Spider(EntityType.SPIDER, {_serverLevel})
	else if any:
		"%{_entity}%" is "cave_spider"
		"%{_entity}%" is "cave spider"
	then:
		set {_NMSEntity} to new CaveSpider(EntityType.CAVE_SPIDER, {_serverLevel})
	else if "%{_entity}%" is "player":
		{_serverPlayer}.connection.send(new ClientboundSetCameraPacket({_serverPlayer}))
		stop

	{_serverPlayer}.connection.send(new ClientboundAddEntityPacket({_NMSEntity}, 0, BlockPos.ZERO))
	{_serverPlayer}.connection.send(new ClientboundSetCameraPacket({_NMSEntity}))

	refreshPlayer({_player})

effect refresh %players%:
	trigger:
		set {_players::*} to expr-1
		loop {_players::*}:
			refreshPlayer(loop-value)

local function refreshPlayer(player: player):
	set {_serverPlayer} to {_player}.getHandle()
	set {_serverLevel} to {_player}.getWorld().getHandle()

	{_serverPlayer}.connection.send(new ClientboundRespawnPacket({_serverPlayer}.createCommonSpawnInfo({_serverLevel}), ClientboundRespawnPacket.KEEP_ALL_DATA))
	{_serverPlayer}.connection.teleport({_player}.getLocation())

	if ({_serverPlayer}.isPassenger()):
		{_serverPlayer}.connection.send(new ClientboundSetPassengersPacket({_serverPlayer}.getVehicle()))

	if ({_serverPlayer}.isVehicle()):
		{_serverPlayer}.connection.send(new ClientboundSetPassengersPacket({_serverPlayer}))

	set {_entities::*} to {_player}.getNearbyEntities(10, 10, 10)

	loop {_entities::*}:
		loop-value is an instance of Mob
		set {_NMSMob} to loop-value.getHandle()
		{_serverPlayer}.equals({_NMSMob}.getLeashHolder())
		{_serverPlayer}.connection.send(new ClientboundSetEntityLinkPacket({_NMSMob}, {_serverPlayer}))

	if {_serverPlayer}.getCooldowns().cooldowns.isEmpty() is not true:
		set {_tickCount} to {_serverPlayer}.getCooldowns().tickCount
		set {_cooldowns::*} to {_serverPlayer}.getCooldowns().cooldowns.entrySet()
		loop {_cooldowns::*}:
			{_serverPlayer}.connection.send(new ClientboundCooldownPacket(loop-value.getKey(), loop-value.getValue().endTime - {_tickCount}))

	{_serverPlayer}.onUpdateAbilities()

	#in 1.21.5, they made the server field private, this should not affect us here. As said here: https://tpgamesnl.gitbook.io/skript-reflect/code-conventions#:~:text=private%20members%20are%20visible%20and%20accessible%20by%20default.
	{_serverPlayer}.server.getPlayerList().sendPlayerPermissionLevel({_serverPlayer})
	{_serverPlayer}.server.getPlayerList().sendLevelInfo({_serverPlayer}, {_serverLevel})
	{_serverPlayer}.server.getPlayerList().sendAllPlayerInfo({_serverPlayer})

#Geometry
function oppositeNumber(number: number) :: number:
	return {_number} * -1

function leftBlocks(location: location, blocks: number) :: location:
	set {_clone} to {_location}
	set {_yaw} to {_clone}.getYaw()

	set {_radians} to {_yaw} - 90
	set {_vec} to vector(oppositeNumber(sin({_radians})), 0, cos({_radians})).normalize().multiply({_blocks})
	return {_clone}.add({_vec})

function rightBlocks(location: location, blocks: number) :: location:
	set {_clone} to {_location}
	set {_yaw} to {_clone}.getYaw()

	set {_radians} to {_yaw} + 90
	set {_vec} to vector(oppositeNumber(sin({_radians})), 0, cos({_radians})).normalize().multiply({_blocks})
	return {_clone}.add({_vec})

item property %string% [string] [custom] [nbt[ tag]] data:
	return type: string
	get:
		return expr-1's expr-2 string tag

item property %string% (int[eger]|number) [custom] [nbt[ tag]] data:
	return type: integer
	get:
		return expr-1's expr-2 int tag

item property %string% %nbttype% [custom] [nbt[ tag]] [data]:
	get:
		set {_data} to expr-2

		if server is not at api change:
			set {_tag} to "PublicBukkitValues;{@pluginname}:%{_data}%"
		else:
			set {_tag} to "minecraft:custom_data;PublicBukkitValues;{@pluginname}:%{_data}%"
		
		set {_nbt} to expr-3 {_tag} of nbt of expr-1
		return {_nbt}

condition %itemstack% has [string] [custom] [nbt[ tag]] data %string% [(as|[set] to) %-string%]:
	check:
		set {_item} to expr-1
		set {_name} to expr-2
		if expr-3 is set:
			set {_value} to expr-3
		if {_value} is not set:
			if server is not at api change:
				nbt compound of expr-1 has tag "PublicBukkitValues;{@pluginname}:%{_name}%"
				continue
			else:
				nbt compound of expr-1 has tag "minecraft:custom_data;PublicBukkitValues;{@pluginname}:%{_name}%"
				continue
		else:
			if server is not at api change:
				if nbt compound of expr-1 doesn't have tag "PublicBukkitValues;{@pluginname}:%{_name}%":
					stop
			else:
				if nbt compound of expr-1 doesn't have tag "minecraft:custom_data;PublicBukkitValues;{@pluginname}:%{_name}%":
					stop
			if server is not at api change:
				set {_tag} to "PublicBukkitValues;{@pluginname}:%{_name}%"
			else:
				set {_tag} to "minecraft:custom_data;PublicBukkitValues;{@pluginname}:%{_name}%"
			string tag {_tag} of nbt compound of {_item} is {_value}
			continue

condition %itemstack% (positive: has|negative: (doesn't|does not) have) [string] [custom] [nbt[ tag]] data %string% [(as|[set] to) %-string%]:
	check:
		if "%parse tags%" contains "positive": 
			if expr-3 is set:
				expr-1 has string tag data expr-2 set to expr-3
				continue
			else:
				expr-1 has string tag data expr-2
				continue
		else:
			if expr-3 is set:
				expr-1 doesn't have string tag data expr-2 set to expr-3
				continue
			else:
				expr-1 doesn't have string tag data expr-2
				continue

condition %itemstack% (positive: has|negative: (doesn't|does not) have) (int[eger]|number) [custom] [nbt[ tag]] data %string% [(as|[set] to) %-int%]:
	check:
		if "%parse tags%" contains "positive": 
			if expr-3 is set:
				expr-1 has int tag data expr-2 set to expr-3
				continue
			else:
				expr-1 has int tag data expr-2
				continue
		else:
			if expr-3 is set:
				expr-1 doesn't have int tag data expr-2 set to expr-3
				continue
			else:
				expr-1 doesn't have int tag data expr-2
				continue

condition %itemstack% (positive: has|negative: (doesn't|does not) have) %nbttype% [custom] [nbt[ tag]] data %string% [(as|[set] to) %-object%]:
	check:
		if "%parse tags%" contains "positive": 
			expr-1's expr-3 expr-2 data is set
			if expr-4 is set:
				expr-1's expr-3 expr-2 is expr-4
				continue
			else:
				continue
		else:
			expr-1's expr-3 expr-2 data is not set
			if expr-4 is set:
				expr-1's expr-3 expr-2 is not expr-4
				continue
			else:
				continue

#Simple tab syntax for items, used to store data easily
expression %itemtype% with %nbttype% [custom] [nbt[ tag]] data %string% (as|to| set to) %object%:
	return type: item
	get:
		set {_item} to expr-1
		set {_name} to expr-3
		set {_value} to expr-4
		if server is not at api change:
			set expr-2 "PublicBukkitValues;{@pluginname}:%{_name}%" of nbt of {_item} to {_value}
		else:
			set expr-2 "minecraft:custom_data;PublicBukkitValues;{@pluginname}:%{_name}%" of nbt of {_item} to {_value}
		return {_item}

expression %itemtype% with [string] [custom] [nbt[ tag]] data %string% (as|to| set to) %string%:
	return type: item
	get:
		return expr-1 with string tag data expr-2 set to expr-3

expression %itemtype% with (int[eger]|number) [custom] [nbt[ tag]] data %string% (as|to| set to) %integer%:
	return type: item
	get:
		return expr-1 with int tag data expr-2 set to expr-3

#Our own boss bar syntax, uses SkBee's boss bar system
expression [new] boss[ ]bar [(named|(with|of) id) %-string%] [(with title|titled) %-string%] [[with (color|colour)|colo[u]red] %-color%] [(with style|styled) %-bossbarstyle%] [with progress %-number%] [lasting [for] %-timespan%] [updating every %-timespan%] [counting (:(up|down))] for %players%:
	return type: bossbar
	get:
		set {_id} to expr-1 ? "%uuid of {_player}%:%random uuid%"
		set {_title} to expr-2 ? "Bossbar"
		set {_color} to expr-3 ? red
		set {_style} to expr-4 ? solid_bar
		set {_progress} to expr-5 ? 100
		set {_lasting} to expr-6
		set {_updating} to expr-7 ? 1 tick
		set {_counting} to the first element of parse tags ? "down" #defaults to counting down
		set {_players::*} to expr-8
		
		#for knowing the ids, refer to this. make sure to set an id to change progress youself.
		set {_bar} to boss bar with id "%{_id}%" with title {_title} with color {_color} with style {_style} with progress {_progress}

		add {_players::*} to bar players of {_bar}
		if {_lasting} is set:
			updateActionBar({_bar}, {_updating}, {_lasting}, {_counting}, {_id})
		return {_bar}

function updateActionBar(bar: bossbar, updating: timespan, lasting: timespan, counting: text, id: text):
	#convert to milliseconds
	set {_time} to ((ticks of {_lasting}) / 20) + unix timestamp of now
	set {_change} to 100 * ((ticks of {_updating}) / (ticks of {_lasting}))
	while {_time} > unix timestamp of now:
		if {_counting} is "up":
			add {_change} to bar progress of {_bar}
		else if {_counting} is "down":
			remove {_change} from bar progress of {_bar}
		if bar players of {_bar} is not set:
			exit 2 sections
		wait {_updating}
	remove bar players of {_bar} from bar players of {_bar}
	delete boss bar with id {_id}